[{"title":"Effective C# 阅读笔记（一）","date":"2019-04-06T06:00:00.000Z","path":"2019/04/06/csharp-effective-01/","text":"本系列为阅读《Effective C#》一书所做的笔记，内容基本来自于该书籍与网上相关文档与博客；由于主要起笔记作用，文章只记录了部分书籍中提到的优化要点，一些不常用的、本人暂时无法理解的、已经掌握或自以为已经掌握的内容不再做记录；内容上比较简要，要获取具体的内容需要查阅相关的资料。 readonly &amp; constreadonly 和 const 都是用于修饰常量的关键字，区别： 作用时期： const：作用于编译期常量，编译过程中编译器会直接将其值对变量进行替换，编译后就无法修改 readonly：作用于运行期常量，运行时执行完构造函数后无法进行修改 作用范围： const：作用于内建类型，int，float，字符串等 readonly：可作用于自定义类型 访问方式： const：编译期直接做了字面值替换，故访问时也直接访问值 readonly：通过引用访问（对于内建类型也是如此） as &amp; is 与强制类型转换 示例 // as 转换 object o = Factory.GetObject(); MyType t = o as MyType; if (t != null) { // 转换成功 } else { // 转换失敗 } // 强制转换 object o = Factory.GetObject(); try { MyType t = (MyType) o; if (t != null) { // 转换成功 } else { // 转换失敗 } } catch { // 异常处理 } 差异 as &amp; is 相对强制转换更安全，运行时效率相对高 as &amp; is 转换不用做异常处理 as &amp; is 不执行任何用户自定义的转换 as 不能用于值类型，因为值类型不能为 null（C# 2.0 后的 Nullable 类型可以支持） Nullable 类型 Nullable types (C# Programming Guide) int number = 1024; object o = (object)number; int? t = o as int; if (t != null) { // 转换成功 } else { // 转换失敗 } 或者可以使用 is： object tempFoo = container.Resolve&lt;Foo>(); // 获取为 Foo 类型 int i = 0; // 值类型转换 if (tempFoo is int) { i = (int)tempFoo; } object tempFoo = container.Resolve&lt;Foo>(); // 获取为 Foo 类型 Logger myFoo = null; // 引用类型转换 if (tempFoo is Logger) { myFoo = tempFoo as Logger; } 用户自定义转换 例如： public class MyClass { private Logger _value; // 隐式自定义类型转换 public static implicit operator Logger(MyClass cls) { return cls._value; } } 类型转换分编译时及运行时，用户自定义类型在做隐式类型转换不支持在运行时转换，故下面会抛出异常： object obj = factory.GetObject&lt;MyClass>(); try { // 编译时没有定义 object 到 Logger 的转换 Logger l = (Logger)obj; if (l != null) { Console.WriteLine(\"convert succ\"); } } catch { Console.WriteLine(\"convert fail\"); } // output: convert fail 需要将类型转换移到编译时： object obj = factory.GetObject&lt;MyClass>(); MyClass cls = obj as MyClass; try { Logger l = (Logger)cls; if (l != null) { Console.WriteLine(\"convert succ\"); } } catch { Console.WriteLine(\"convert fail\"); } // output: convert succ delegateTODO box &amp; unbox 定义： 装箱：值类型放入非类型化的引用对象中（object） 拆箱：从已经装箱的对象中，将值拷贝一份出来 开销原因： 装箱、拆箱本身的消耗 装箱时除了拷贝原值，还会实现其实现的接口（例如对于struct） 装箱时分配了heap内存，产生了gc 拆箱时每次都需要从箱中拷贝一次原值 注意点： 隐式转换： // origin int number = 1024; string str = string.Format(\"number={0}\", number); // 等同于 int number = 1024; object number_box = (object)number; int number_unbox = (int)number_box; string number_str = number_unbox.ToString(); string str = string.Format(\"number={0}\", number_str); new 修饰符 作用 修饰子类中与父类同名的非虚方法，用于做出不同的表现 public class Base { public void Func() { Debug.Log(\"Base 111\"); } } public class Derived { public void Func() { Debug.Log(\"Derived 222\"); } } // ... object obj = FactoryFunc(); Base b = obj as Base; b.Func(); // 'Base 111' Derived d = obj as Derived; d.Func(); // 'Derived 222' 缺陷 问题在于，使用 new 修饰符会导致，同一个对象的同一个接口会具有不同的表现（取决于作为父类还是子类的引用），容易造成误解","tags":[{"name":"c#","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"Sublime插件开发：在入门前放弃","date":"2019-02-06T16:00:00.000Z","path":"2019/02/07/subl-simple-search/","text":"简介前些日子在做功能的时候，感觉工具非常不趁手，决心自己撸个插件改善一下开发效率，于是简单接触了一下 sublime 插件开发的流程，虽然没啥精力折腾复杂的功能，但将折腾的过程记录于此，方便之后心血来潮来一发大的的时候有个参考，涉及的内容不深，仅供入门了解。 sublime api 可参见官网。 How-to-Run首先是建立插件能够运行的环境，找到 sublime 插件的目录： # mac /Users/\"User Name\"/Library/Application Support/Sublime Text 3/Packages/ # windows C:\\Users\\\"User Name\"\\AppData\\Roaming\\Sublime Text 3\\Packages\\ 在其中建立测试用文件夹，例如：PluginTest，接着通过 sublime 菜单创建示例 plugin 文件保存到测试文件夹：Sublime -&gt; Tools -&gt; Developer -&gt; New Plugin 文件内容为： import sublime import sublime_plugin class ExampleCommand(sublime_plugin.TextCommand): def run(self, edit): self.view.insert(edit, 0, \"Hello, World!\") 接下来，通过 ctrl+` 打开 console，输入： view.run_command('example') # 取 ExampleCommand 的前缀 example 即可看到该插件的效果：在文件开始处插入 “Hello, World!” : Sublime 核心组件在 sublime 中，编辑器自身比较常用并且需要关注的几个类有： Window：对应 sublime 中的一个窗口 View：对应窗口中的每个文本页签 Selection：编辑器中选中的部分 Region：指代 buffer 中的一个区域，例如 Region(0, 1) 表示该 View 里的第一个字符 插件 api command 在前面的示例代码中，使用到了 command 来运行指令，sublime 中共有三种 command （ApplicationCommand，WindowCommand，TextCommand），三者基本是一样的，只是作用域不同： ApplicationCommand：作用于整个 sublime 进程 WindowCommand：作用于每个打开的窗口 TextCommand：作用于每个 tab callback sublime 中很多逻辑的处理都需要依赖回调事件，例如保存的回调、修改的回调等，具体的回调可以在 api 文档中查阅: 使用回调的话需要继承 EventListener 类： class EventListener(sublime_plugin.EventListener): def on_pre_save(self, view): print('on_pre_save', view.id(), view.file_name()) 实现一个简单的搜索插件在这里会通过实现一个简单的插件，来了解 sublime 插件的开发流程，该插件的功能是通过快捷键，快速搜索选中的关键词，搜索链接可配置，比如 Google、必应词典、Unity3D API 文档等。 实现代码 代码非常简单，已经加入注释说明，如下： import sublime import sublime_plugin import webbrowser class SimpleSearchCommand(sublime_plugin.TextCommand): urlList = []; displayList = []; def run(self, edit): # 如果有选中的文字，则直接进行搜索；如果无选中文字，则打开输入框输入文本进行搜索 selection = self.view.substr(self.view.sel()[0]); if len(selection) == 0: self.view.window().show_input_panel(\"Search For:\", selection, self.on_input_done, None, None); else: self.on_input_done(selection); def on_input_done(self, string): # init self.searchStr = string; self.urlList = []; self.displayList = []; # 从设置中加载配置的搜索选项，并创建一个 quick panel settings = sublime.load_settings('SimpleSearch.sublime-settings'); self.urlList = settings.get('custom_url'); if self.urlList is not None: for url in self.urlList: display = [ url[\"title\"] + \" : \\'\" + self.searchStr + \"\\'\", url[\"content\"], ]; self.displayList.append(display); # 设置 quick panel 的回调，如果选择完毕则进行搜索 self.view.window().show_quick_panel(self.displayList, self.on_select_done, 0, 0, None); def on_select_done(self, index): # cancel if index == -1: return; # search searchUrl = self.urlList[index][\"url\"]; DoSearch(self.searchStr, searchUrl); def DoSearch(searchStr, searchUrl): # 进行搜索的核心代码其实只有一行： webbrowser.open_new_tab(searchUrl.format(searchStr)); return; 搜索配置 代码中通过配置文件加载了不同的搜索方式，而添加配置文件的方式也很简单，直接在插件代码所在文件夹下创建配置文件 SimpleSearch.sublime-settings : { \"custom_url\": [ { \"title\": \"Unity3D\", \"content\": \"unity.com\", \"url\": \"http://docs.unity3d.com/ScriptReference/30_search.html?q={0}\", }, { \"title\": \"Google\", \"content\": \"google.com\", \"url\": \"https://www.google.com/search?q={0}\", }, { \"title\": \"Bing Dict\", \"content\": \"dict.bing.com\", \"url\": \"https://cn.bing.com/dict/search?q={0}\", }, ] } title 字段对应的是 quick panel 中显示的标题，content 为 quick panel 中的说明信息，url 即搜索用的 url： 快捷键配置 为了方便使用，还可以配置专用的快捷键，添加快捷键配置也是创建一个配置文件，同样，在插件代码所在路径添加 Default (OSX).sublime-keymap： [ { \"keys\": [\"ctrl+'\"], \"command\": \"simple_search\" } ] 这样，通过 ctrl+’ 快捷键即可调用插件。 插件配置 光添加以上两个配置文件还并不能正常的起作用，还需要一个整个插件的总配置文件：SimpleSearch.sublime-commands： [ { \"caption\": \"SimpleSearch: Settings\", \"command\": \"edit_settings\", \"args\": { \"base_file\": \"${packages}/SimpleSearch/SimpleSearch.sublime-settings\", \"default\": \"\" } }, { \"caption\": \"SimpleSearch: Key Bindings\", \"command\": \"edit_settings\", \"args\": { \"base_file\": \"${packages}/SimpleSearch/Default (${platform}).sublime-keymap\", } } ] 以上的配置引用了之前的搜素设置与快捷键配置文件，配置文件的命名其实可以随意调整，同时支持参数。例如快捷键配置文件的路径中饮用了 ${platform} 参数，该参数会让 sublime 在不同平台去引用不同的配置文件（Windows、Linux、OSX等）。 配置文件中的 caption 字段还配置了 sublime 中的 UI 选项入口，可以通过 sublime 选项进入插件设置，修改配置： 使用效果 插件效果如下： 总结看看日期，这篇文章开写的时候是2018-10-15，又是一篇拖了小半年的文章，趁着过年挤牙膏挤完了，总算了结了一件事，但愿拖延症能治。。。","tags":[{"name":"sublime","slug":"sublime","permalink":"http://yoursite.com/tags/sublime/"}]},{"title":"Doge-Jump微信小游戏","date":"2018-10-14T16:00:00.000Z","path":"2018/10/15/minigame-dogejump/","text":"简介本文用于记录微信小游戏开放之后，自己学习工作之余的娱乐练手项目，便于将来回顾与参考，其为一个简单的跑酷小游戏，直接基于h5开发，Github地址为： Doge-Jump 本文将分为以下几个章节做记录： 微信小游戏介绍 开发准备 基础框架 游戏逻辑 总结 注：本文完成时，业已发现原代码中存在的各种 bug 和缺陷，由于疾病（懒癌）的关系，不便于再做修改，故原代码只提供参考价值，注明于此。 微信小游戏介绍继微信小程序之后，微信开放了小游戏的接口，其随开放带来的跳一跳小游戏在一夜之间攻占了整个朋友圈，也体现了目前微信小游戏的特点与定位：简单、休闲、魔性。 微信小游戏基于 HTML5 平台，使用 JavaScript 语言开发，可以直接通过 HTML5 的接口进行开发，也可以使用现成的 HTML5 开发引擎，例如 cocos2d 、 egret 等。 开发准备好(xian)奇(de)之(dan)下(teng)，我开始接触小游戏的开发，通过微信官网的文档 微信小游戏开发 可以找到开发工具的下载和开发文档（在我刚开始尝试微信小游戏的开发时，还并没有小游戏的文档，现在微信官方已补全，故可通过官方文档快速上手小游戏）按照官方文档中提供的介绍，下载开发工具安装，即可直接进入小游戏的开发界面： 小游戏开发者工具的最主要的功能就是用于编译和预览（当然还有发布等等），为了照顾个人习惯，实际上平常代码的编辑我还是使用 sublime text 进行的，所以一般的开发流程就是，在编辑器中把代码码好，然后在开发者工具中预览即可。 基础框架接下来就是进行小游戏的开发，由于没有使用现有的引擎（不要问我为什么，当时太年轻），以及直接使用 H5 的接口开发非常的不好用，所以需要对原生接口进行封装，抽象出一套比较好用的游戏开发接口，然后再进行游戏逻辑的开发。这套接口的提供的主要功能有以下几种： GameManager ：游戏主管理器，存储游戏全局数据，进行全局设置，控制游戏的开始等等 EventManager ：事件管理，基于观察者模式的事件分发系统 InputManager ：游戏输入控制，主要是触屏输入 SceneManager ：场景管理，场景切换等功能 PhysicsManager ：简易的物理引擎，处理碰撞检测等 MusicManager ：音效管理 ActionManager ：Action 系统，其实是一套类似 Tween 动画的动画系统 而游戏中的基本组件有： Node ：游戏中的基本元素，类似 Unity 中的 GameObject ，cocos2d 中的 Node 。是游戏中的基础节点，用于构造整个游戏场景的结构 Sprite ：精灵，继承自 Node ，游戏中最基础的渲染节点，可以加载图片资源进行显示 Animation ：动画，继承自 Sprite ，简易的帧动画实现 Vector，Rect ：基础数据结构，比如 Vector 可用于大小、位置的存储， Rect 用于包围盒的描述等 Selectable，Button，Text ：基础的 UI 实现，Selectable 是一个基础类，需要接收点击事件的 UI 组件（例如 Button ）继承于此 Logger ：日志，虽然并没有任何管理功能。。。 游戏入口小游戏提供了一个统一的入口，即 js/main.js 文件，在这里，游戏框架做了各个管理器的初始化工作，并搭建了基本的游戏主循环，控制了游戏逻辑、渲染、物理等各个模块的更新： // js/main.js // 初始化 restart() { this.managers = []; this.managers.push(GameManager.instance); this.managers.push(SceneManager.instance); this.managers.push(ActionManager.instance); this.managers.push(EventManager.instance); this.managers.push(MusicManager.instance); this.managers.push(InputManager.instance); this.managers.push(PhysicsManager.instance); this.managers.forEach(function(mgr) { mgr.restart(); }); // 设计缺陷，使用到的场景必须先在 SceneManager 里注册 SceneManager.instance.addScene(\"MainScene\", function() { return new MainScene(); }); SceneManager.instance.addScene(\"PlayScene\", function() { return new PlayScene(); }); SceneManager.instance.switchToScene(\"MainScene\"); // 启动游戏循环 window.requestAnimationFrame(this.loop.bind(this), canvas); } // 主循环 loop() { if (!this.lastTime) { this.lastTime = new Date().getTime(); } this.curTime = new Date().getTime(); // 循环 this.update((this.curTime - this.lastTime) / 1000); this.lateUpdate(); this.render(); this.lastTime = this.curTime; // 场景管理：是否结束游戏 if (SceneManager.instance.quitGame) { this.restart(); return; } window.requestAnimationFrame(this.loop.bind(this), canvas); } // 逻辑更新，部分管理器之间的更新顺序是有要求的 update(dt) { GameManager.instance.update(dt); PhysicsManager.instance.update(dt); InputManager.instance.update(dt); SceneManager.instance.update(dt); ActionManager.instance.update(dt); } // 逻辑更新之后的 late 更新，用于处理一些特殊逻辑 lateUpdate() { SceneManager.instance.lateUpdate(); } // 渲染 render() { ctx.fillStyle = \"#ffffff\"; ctx.fillRect(0, 0, GameManager.instance.screenWidth, GameManager.instance.screenHeight); SceneManager.instance.render(ctx); } 以上有注释，就不做具体说明。 场景结构由于早期使用 cocos2d 挺长一段时间，研究了一会它的代码，所以这里搭建的简易框架风格也跟 cocos2d 有点相似，比如场景为树形结构，类似于： |-- Scene |-- BackgroudLayer |-- Mountain |-- House |-- Sky |-- PlaygroudLayer |-- Player |-- ForegroudLayer |-- Tree |-- UILayer |-- Score |-- Money 上面每一个物体都是一个 Node ，Node 之间的层级设置通过 AddChild 操作来实现，例如： export default class MainScene extends Scene { constructor() { super(); // 添加一个 Button let startBtn = new Button('images/ui/BtnNormal.png', 'images/ui/BtnSelected.png', 128, 64, function(point) { // Button 点击时切换场景为 PlayScene SceneManager.instance.switchToScene(\"PlayScene\"); }); this.addChild(startBtn); // 将 Button 添加为 MainScene 的子节点 startBtn.position = new Vector2(100, 100); // 给 Button 添加 Text let startBtnName = new Text('START', 100, \"#000000\", \"middle\"); startBtn.addChild(startBtnName); // 将 Text 添加为 StartBtn 的子节点 startBtnName.position = new Vector2(0, 0); } 上面通过两次 AddChild 操作，形成的场景结构为： |-- MainScene |-- StartBtn |-- StartBtnName 显示效果为： 其中可以看出 Button 位于 Scene 上，Text 位于 Button 上的显示层级。 通过父子节点的形式来构成场景的好处有几个： 解决坐标系问题：如果有父子节点，子节点的位置定义是就不必使用世界坐标，而是使用相对父节点的相对坐标，更易于使用和理解 解决渲染顺序问题：通过特定顺序（例如前序）遍历场景树，可以形成一个有序的队列，通过这个队列可以很明确地定义渲染的顺序，表现为父节点必定比子节点先渲染，兄弟节点间在前面的先渲染 场景划分易于理解，比如场景中可以分作几个层，可以明显看出每个层之间的前后关系，逻辑上比较容易让人接受 等等 Node 设计Node 是框架中的基本元素，所有游戏中的组件都是 Node，Node 复杂了许多方面的工作，例如前面提到的构成场景结构，还有生命周期管理，坐标计算，碰撞事件等等。 先从生命周期讲起，Node 有这么几个生命周期： constructor ：初始化，Node 在创建时调用，仅会调用一次 update ：逻辑更新，如果当前 Node 在被激活的场景中，则会每帧更新 render ：渲染更新，Sprite 及其子类会被调用，在 update 之后，一般不需要手动处理 onEnable ：Node 每次启动的时候调用 onDisable ：与 onEnable 相对，同时在 destroy 的时候也会被调用 坐标计算方面，主要分为相对坐标以及世界坐标。 相对坐标（local position）：即当前 Node 相对其父节点的位置 世界坐标（world position）：当前 Node 在世界坐标系中的位置例如父节点坐标为（100，100），子节点相对坐标为（100，0），则子节点世界坐标为（200，100）；使用两种坐标的好处是子节点的位置更容易理解（只要相对其父节点结算即可），另一方面是当父节点改变时，子节点的坐标可以非常方便的进行计算 碰撞事件，为了方便（主要还是太懒），Node 节点直接包含了碰撞的接口： onCollisionBegin(other, tag) { // Logger.print(\"onCollisionBegin\"); } onCollision(other, tag) { // Logger.print(\"onCollision\"); } onCollisionEnd(other, tag) { // Logger.print(\"onCollisionEnd\"); } 而要触发碰撞检测，需要通过 PhysicsManager 进行注册，例如在示例游戏中 player 的注册为： onEnable() { super.onEnable(); // 注册本节点为 \"PLAYER\" 类型 PhysicsManager.instance.addCollider(\"PLAYER\", this); // 添加碰撞规则（允许 \"PLAYER\" 类型节点与 \"ROCK\"，\"REDPOCKET\" 类型的节点产生碰撞） PhysicsManager.instance.addRule(\"PLAYER\", \"ROCK\"); PhysicsManager.instance.addRule(\"PLAYER\", \"REDPOCKET\"); } onDisable() { super.onDisable(); // disable 时进行反注册 PhysicsManager.instance.removeCollider(\"PLAYER\", this); PhysicsManager.instance.removeRule(\"PLAYER\", \"ROCK\"); PhysicsManager.instance.removeRule(\"PLAYER\", \"REDPOCKET\"); } 游戏逻辑把前面的垃圾代码撸完，目前我们就有了完成一个简单小游戏的基础要素： 节点（Node） 精灵图显示（Sprite） 场景管理（SceneManager） 事件系统（EventManager） 碰撞检测（PhysicsManager） 用户输入（InputManager） UI（Button，Text） 接下来就可以开始利用上面的各个模块开始组建简单的游戏，在本示例中，是一个名为 Doge-Jump 的小游戏，它非常简单，只有两个场景： MainScene开始场景，里面只有一个开始按钮，点击时跳转到 PlayScene ： export default class MainScene extends Scene { constructor() { super(); // 创建开始按钮 let startBtn = new Button('images/ui/BtnNormal.png', 'images/ui/BtnSelected.png', 128, 64, function(point) { SceneManager.instance.switchToScene(\"PlayScene\"); }); this.addChild(startBtn); startBtn.position = new Vector2(gm.designWidth / 2, gm.designHeight / 2); // 设置按钮文字 let startBtnName = new Text('START', 100, \"#000000\", \"middle\"); startBtn.addChild(startBtnName); startBtnName.position = new Vector2(0, 0); } } PlayScene游玩场景里面其实只有主角 Player 、障碍 Rock 、奖励 RedPocket 、分数 Score 、重开始对话框 Dialog 几种物体（具体代码不再凑篇幅）： Player： 定义了 jump 函数，用于让主角进行跳跃，当玩家点击屏幕时触发跳跃； 注册了碰撞检测，当与奖励或者障碍碰撞时会回调处理相应逻辑 监听了玩家死亡事件，处理停止动画等逻辑 Rock / RedPocket：都拥有一个对应 Creator 来进行管理，按照一定的时间规律进行创建（其实就是随机 - _ -|| ） Score：监听得分事件，显示对应分数 Dialog：当玩家死亡时弹出，提示是否重新开始 游戏非常简单，开始游戏，点击屏幕控制 Doge 跳跃，不断得分就可以了～ 总结自此，拖了这么久终于把这篇文章的牙膏挤完了（拖了大半年），虽然做的东西其实并没有什么实际意义，但是接触到一些新东西，心血来潮去研究一下还是非常有意思的（打发了春节的无聊时光），但愿以后加班掉发之余还能有时间写写好玩的代码，以及希望有能治好拖延症的药。。。","tags":[{"name":"minigame","slug":"minigame","permalink":"http://yoursite.com/tags/minigame/"}]},{"title":"UI点击穿透组件","date":"2018-08-05T04:00:00.000Z","path":"2018/08/05/ugui-uiraycast-receiver/","text":"功能概述某些时候，我们想要实现这样一种功能：点击屏幕上的一块区域，该区域触发一个事件，同时位于该区域以下的UI组件依然能够接收的到点击事件。比如在游戏的背包系统中，点击某个道具会显示道具的信息 Tips ，在 Tips 存在的时候，点击第二个道具，打开第二个道具的 Tips ，同时关闭第一个道具的 Tips 。 （图片来自网络） 如果采用 UGUI 框架来实现的话，我们知道一个 UI 组件想要接收点击事件，需要勾选其 “Raycast Target” 选项，但一旦勾选这个选项，位于其下的 UI 组件就无法接收到点击事件，故需要通过其它手段来实现这样的功能。 实现思路特殊逻辑实现对于上面提到的背包 Tips 需求，其实可以直接在逻辑代码里面做处理来实现： 首先取消 Tips 的 “Raycast Target” ，避免其影响下一层的事件接收 然后在每个道具的事件处理中都先关闭上一条 Tips ，再打开自己的 Tips 但此时出现了新的问题，比如背包系统中经常会有多种类型的背包，通过 Tab 来切换不同的类型，如果 Tips 无法接收事件，那意味着在这些 Tab 的事件处理中也要加上关闭 Tips 的处理，否则在切换类型时 Tips 无法关闭。在这样的处理下，原本的逻辑就变得复杂了，如果还有其它组件有 Tab 类似的功能，意味着每一个这样的组件都要加相关的处理，缺少通用性。 使用 EventHandler参考博客 《 Unity3D 之将 UI 的点击事件渗透下去》 的内容，通过继承 EventHandler 的方法，让当前脚本接收到事件的同时将事件再次传递下去： using UnityEngine; using System.Collections; using UnityEngine.EventSystems; using UnityEngine.UI; using System.Collections.Generic; public class Test : MonoBehaviour, IPointerClickHandler, IPointerDownHandler, IPointerUpHandler { // 监听按下 public void OnPointerDown(PointerEventData eventData) { PassEvent(eventData, ExecuteEvents.pointerDownHandler); } // 监听抬起 public void OnPointerUp(PointerEventData eventData) { PassEvent(eventData, ExecuteEvents.pointerUpHandler); } // 监听点击 public void OnPointerClick(PointerEventData eventData) { PassEvent(eventData, ExecuteEvents.submitHandler); PassEvent(eventData, ExecuteEvents.pointerClickHandler); } // 把事件透下去 public void PassEvent&lt;T>(PointerEventData data, ExecuteEvents.EventFunction&lt;T> function) where T : IEventSystemHandler { List&lt;RaycastResult> results = new List&lt;RaycastResult>(); EventSystem.current.RaycastAll(data, results); GameObject current = data.pointerCurrentRaycast.gameObject ; for(int i = 0; i &lt; results.Count; ++i) { if(current != results[i].gameObject) { ExecuteEvents.Execute(results[i].gameObject, data,function); // RaycastAll后ugui会自己排序，如果你只想响应透下去的最近的一个响应， // 这里ExecuteEvents.Execute后直接break就行。 // break; } } } } 但这样存在的问题是，如果被遮挡的组件除去点击事件还有其它类型的事件要接收（例如拖拽等），意味着要再给其它类型的事件做处理，并且很多事件不仅仅是直接将事件继续传递就可以了的，其中的逻辑没有处理好的话非常容易出现问题，故这套方案的局限性比较大。 利用 EventSystem.RaycastAll通过分析 UGUI 的源码（ UGUI 为开源代码：UGUI Source Code），可以知道点击事件是由 EventSystem 来驱动的。 在 EventSystem 的 Update 中，对当前的 InputMoudle 进行了更新，默认的InputMoudle（ PC 上为 StandaloneInputMoudle ，移动端为 TouchInputMoudle ，都继承自 PointerInputModule ）在每次更新的时候，会利用 EventSystem.RaycastAll 接口来获取当前点击点能够触发事件的所有 UI 组件，并从中找出排在最前面的一个： // PointerInputModule.cs protected PointerEventData GetTouchPointerEventData(Touch input, out bool pressed, out bool released) { // 初始化 PointerData PointerEventData pointerData; var created = GetPointerData(input.fingerId, out pointerData, true); pointerData.Reset(); pressed = created || (input.phase == TouchPhase.Began); released = (input.phase == TouchPhase.Canceled) || (input.phase == TouchPhase.Ended); if (created) pointerData.position = input.position; if (pressed) pointerData.delta = Vector2.zero; else pointerData.delta = input.position - pointerData.position; pointerData.position = input.position; pointerData.button = PointerEventData.InputButton.Left; // 获取所有能接收该 Point 事件的 UI 组件 eventSystem.RaycastAll(pointerData, m_RaycastResultCache); // 找出排在最前面的 UI 组件 var raycast = FindFirstRaycast(m_RaycastResultCache); pointerData.pointerCurrentRaycast = raycast; m_RaycastResultCache.Clear(); return pointerData; } 获取到最前面的 UI 组件后，即可对它进行事件处理。 判断一个 UI 组件是否能够被触发事件，是由该组件的 Raycast 接口决定的：EventSystem.RaycastAll 时会对所有能够接收事件的 UI 组件调用其 Raycast 接口，如果该接口返回 True ，说明其处在点击范围内，会加入能够接收事件的 UI 队列中。 知道了这一点，面对我们需要解决的需求时，可以采取的思路是： 先开启 “Raycast Target” ，要能够接收点击事件 如果处在点击范围内，进行记录，但让 Raycast 接口返回 False ，避免隔断其它 UI 组件的事件处理 如果记录中本 UI 组件处在点击范围内，则手动进行一次 EventSystem.RaycastAll 检测，并判断自身是否是队首的 UI 组件，如果是，则进行事件处理 通过上面第二点，可以做到事件穿透，通过第三点，可以做到当前 UI 组件的事件处理。实现了需求。核心代码如下： public override bool Raycast(Vector2 sp, Camera eventCamera) { // 记录是否在点击范围内 isRaycasted = base.Raycast(sp, eventCamera); if (isRaycastTesting) return isRaycasted; else return false; } public void Update() { // 如果不需要检测，直接返回，避免不必要的计算 if (!isRaycasted) return; isRaycasted = false; // 获取当前点击点的位置 #if UNITY_EDITOR || UNITY_STANDALONE if (Input.GetMouseButtonDown(0)) { touchPosition = Input.mousePosition; #else if (Input.touchCount > 0 &amp;&amp; Input.touches[0].phase == TouchPhase.Began) { touchPosition = Input.touches[0].position; #endif // 手动调用 EventSystem.RaycastAll var data = new PointerEventData(EventSystem.current); data.position = touchPosition; data.delta = Vector2.zero; data.button = PointerEventData.InputButton.Left; var results = new List&lt;RaycastResult>(); isRaycastTesting = true; EventSystem.current.RaycastAll(data, results); isRaycastTesting = false; // 判断是否是队首 UI bool isFirstObj = false; for (int i = 0; i &lt; results.Count; ++i) { if (results[i].gameObject != null) { isFirstObj = (results[i].gameObject == gameObject); break; } } // 如果是，进行事件处理 if (isFirstObj) { // do sth. } } } 优化方向现存缺陷虽然以上使用 EventSystem.RaycastAll 手动进行一次检测的方式可以解决目前碰到的问题，但是在性能等方面，其还是存在一些优化点： 当前 UI 是否要进行事件处理的判断是在 Update 中做的，虽然不在点击区域之内的时候 Update 会立即返回不进行计算，但是大量的调用还是会存在一定的开销 每一个挂载脚本的 UI 组件都有可能触发 EventSystem.RaycastAll ，如果某一个区域重叠了大量的 UI 组件，都触发检测的话，可能对性能有较大的影响 优化思路 可以添加一个管理器，所有需要进行判断的逻辑放到管理器进行处理，如果有 UI 需要进行检测，就都加入列表中，由管理器进行统一的 EventSystem.RaycastAll 调用，这样一个是可以减少 Update 的调用，另一个也避免了太多的 EventSystem.RaycastAll 另一方面，通过之前的 UGUI 源码分析可以知道，之所以我们要采取手动进行 EventSystem.RaycastAll 操作来实现需求，是因为默认的 InputMoudle 进行该操作之后只保留了队首的 UI ，导致无法对其后的 UI 进行处理，无法实现穿透功能；故其实我们可以通过实现自己的 InputMoudle 来解决这个问题，在自己实现的 InputMoudle 中保存相关的数据，需要的时候就可以直接进行取用，避免了手动调用的开销","tags":[{"name":"unity","slug":"unity","permalink":"http://yoursite.com/tags/unity/"},{"name":"ui","slug":"ui","permalink":"http://yoursite.com/tags/ui/"}]},{"title":"\"游戏心理学\"相关笔记","date":"2017-01-18T13:41:31.000Z","path":"2017/01/18/gamedesign-psychology/","text":"游戏中的心理学乐趣原理 三要素：玩法，规则，奖惩： 例子，对于Pacman这款游戏，其玩法就是玩家可以上下左右移动；规则就是玩家需要吃完地图上的所有豆子，并且尽量躲避鬼魂；奖惩体现在游戏的分数上，如果持续吃豆子或者进入下一关等，玩家的游戏积分会增加，如果玩家被鬼魂吃掉，则会损失生命导致游戏结束。 心流理论(wiki)：一种将个人精神力完全投注在某种活动上的感觉；心流产生时同时会有高度的兴奋及充实感。 例子：xxx 强化理论 巴甫洛夫条件反射(wiki)： 斯金纳的操作条件反射(wiki)： 强化：用以提高个体做出某种行为的频率，分为正强化与负强化。正强化：当个体做出一个行为后，给予其一个积极强化物。负强化：当个体做出一个行为后，撤去其一个消极强化物。 例如在《风之旅人》中，设计师的目的是鼓励玩家之间多进行互助，它采取的方式是，后一个玩家如果行走在前一个玩家的足迹路径上时，他的速度会增加，这样就可以很快地追上前面的人，并且当玩家在一起的时候，他们的能力会变得强大。这就是一种正强化。 惩罚：与强化相反，用以降低个体做出某种行为的频率。也同样分为正反两种。例如在很多的团队竞技游戏里面，逃跑这种行为是不被鼓励的，所以玩家如果逃跑，他的逃跑率就会不断增加，逃跑率过高甚至会导致其无法继续游戏。 消退：如果个体做出某个以前被强化过的行为，但是却没有得到通常的强化，那么就有可能降低做出此类行为的频率。 强化理论(wiki)： 固定比率强化：事先定下一个次数，每当个体做出某行为达到这个次数，就给予一次强化。例如在《超级玛丽》中，玩家每获得100个金币，就会自动购买一次生命。 变化比率强化：按照一个概率进行强化。例如强化的概率为0.1，那么个体平均做出十次指定行为，就会获得一次强化。但是由于指定的是频率，所以并不固定为每十次强化一次。例如炉石开卡包。。。 固定时距强化：不管个体做出行为的次数，均在一个固定时间过后给予一次强化。 变化时距强化：类似于变化比率强化。只不过平均的是时间。 动机理论 内在动机与外在动机(wiki)： 内在动机（或内在激励）指的是任务本身的兴趣或愉悦带来的动机，这存在于个体内部而非依赖于任何外部力量的驱动。 外在动机（或外在激励）指的是从事某个活动的行为是为了取得外部收入，这种动机常常与内在动机相抵触。外在动机来源于个体的外部。通常的外在动机如金钱、分数、强迫、惩罚等。竞争总体上也属于外在动机，因为它鼓励人们打败胜过其他人，而非享受行为内在的回报。有观点认为个体的独特性与任务取得的奖杯徽章也属于外在动机。 可以拿游戏的新手引导作为说明，很多网游是通过触发外在动机的方式来做新手引导的，例如《梦幻西游》中，你只需要跟着屏幕上显示的高亮图标进行点击就可以完成引导任务，多数情况下玩家甚至不知道这样做的目的。这一类引导方式在每一次引导完成后通常会通过道具奖励来激励玩家继续进行任务（此处的奖励就是外在动机）。而在《巫师》中，游戏中的引导是通过与剧情相关的内容来实现的，例如根据剧情玩家要到某处做任务，任务途中会遭遇战斗，于是新手引导就可以与剧情相结合起来，只要玩家对剧情感兴趣，就会一直玩下去，完成引导，此处用到的就是内在动机。 其它参考链接 《风之旅人》谈游戏设计(link)； 巴甫洛夫的经典条件反射和斯金纳的操作条件反射的区别和联系: (zhihu)；","tags":[{"name":"gamedesign","slug":"gamedesign","permalink":"http://yoursite.com/tags/gamedesign/"}]},{"title":"Cocos2d-lua绑定自定义c++类","date":"2016-07-08T11:41:11.000Z","path":"2016/07/08/cocos2d-lua-binding/","text":"最近在使用cocos2d-lua写一些小游戏，遇到了需要在lua中调用自定义的c++类的情况，于是花了一下午时间来踩这个坑，目前终于成功跑起来了，故在此做一个记录。 lua调用静态c++函数在lua中调用c++有很多中办法，例如可以直接使用lua_register来注册一个静态函数。如下： #include &lt;lua.h> #include &lt;lualib.h> #include &lt;lauxlib.h> int test(lua_State *L) { int n = lua_tonumber(L, 1); lua_pushnumber(L, n + 1); return 1; } int main() { lua_State *L = lua_open(); luaL_openlibs(L); lua_register(L, \"test\", test); luaL_dofile(L, \"a.lua\"); lua_close(L); return 0; } 在test函数中，lua_tonumber(L, 1)获取了L环境中给test输入的第一个参数，因为lua与c++的交互是通过一个栈来进行的，所以函数返回之前使用了lua_pushnumber来向栈中压入一个值。注意在lua中函数返回的可以不止一个值，所以在这里也可以多次push，最后test的return值意味着此函数一共返回了多少个值。test函数定义好之后，通过lua_register向lua环境注册这个函数，这样在lua代码中就可以对此函数进行调用了。 print(test(1)) lua调用自定义c++类因为在实际使用中不可能只使用到静态函数，还要经常使用自己定义的c++类，如果直接使用类似于lua_register的方式来注册c++类，那么工作量会非常大。这时候可以使用类似于tolua++之类的第三方工具来进行注册，但是这里不再赘述，就直接讲如何使用cocos2d自带的bindings-generator工具进行注册。 实现所需的c++类首先给出一个示例用的c++类： // MyClass.h #include \"cocos2d.h\" using namespace cocos2d; class MyClass : public Ref { public: MyClass() {} ~MyClass() {} virtual bool init() { return true; } CREATE_FUNC(MyClass); // used to test int test(int i); }; // MyClass.cpp #include \"MyClass.h\" int MyClass::test(int i) { return i + 1; } 这里应该注意一点，就是在cocos2d中的自定义类应当继承ref或者其子类，因为这样可以让cocos2d将内存管理起来，不需要自己来操心。如果lua工程目录为LuaTest/，则将c++类的两个文件放到LuaTest/frameworks/runtime-src/Classes/下面，因为新添加这两个文件，所以也要记得修改对应的makefile，例如我是在linux上进行测试的，则修改CMakeList.txt，将参加编译的文件修改为： set(GAME_SRC runtime-src/proj.linux/main.cpp runtime-src/Classes/AppDelegate.cpp runtime-src/Classes/MyClass.cpp ) 即添加了刚刚创建的MyClass。如果是其它平台，例如android，则修改对应的Android.mk，如果是xcode的工程，则需要将文件拖入工程。 创建配置文件，并使用脚本生成注册用c++文件接下来，需要使用bindings-generator来自动生成一个用于注册的c++文件。此时切换目录到LuaTest/frameworks/cocos2d-x/tools/tolua/下，可以看到这里有很多.ini文件，以及一个genbindings.py文件。.ini文件定义了从c++文件生成用于注册的c++文件的规则，而genbindings.py则是cocos2d提供的脚本，可以根据ini规则生成用于注册的c++文件。 为了注册MyClass文件，简单的话可以直接复制一个ini文件，例如cocos2dx.ini，然后对其进行修改，重点要修改的内容为： [MyClass] prefix = MyClass target_namespace = custom headers = %(cocosdir)s/../runtime-src/Classes/MyClass.h classes = MyClass 其中target_namespace为命名空间，例如cocos2d在lua中的命名空间就为cc。headers指向我们一开始创建的原始c++文件，classes中可以声明多个类，用空格隔开；因为我们的文件中只有MyClass一个类，所以这里就只写MyClass了。修改完，命名为MyClass.ini保存。然后是对脚本进行修改。其实可以直接修改genbindings.py，但是因为其中涉及到太多文件，每次运行的时间可能会太长，所以这里又拷贝一份，命名为genbindings_custom.py。打开文件，在141行左右，修改： cmd_args = {'cocos2dx.ini' : ('cocos2d-x', 'lua_cocos2dx_auto'), \\ 'cocos2dx_extension.ini' : ('cocos2dx_extension', 'lua_cocos2dx_extension_auto'), \\ 'cocos2dx_ui.ini' : ('cocos2dx_ui', 'lua_cocos2dx_ui_auto'), \\ 'cocos2dx_studio.ini' : ('cocos2dx_studio', 'lua_cocos2dx_studio_auto'), \\ 'cocos2dx_spine.ini' : ('cocos2dx_spine', 'lua_cocos2dx_spine_auto'), \\ 'cocos2dx_physics.ini' : ('cocos2dx_physics', 'lua_cocos2dx_physics_auto'), \\ 'cocos2dx_experimental_video.ini' : ('cocos2dx_experimental_video', 'lua_cocos2dx_experimental_video_auto'), \\ 'cocos2dx_experimental.ini' : ('cocos2dx_experimental', 'lua_cocos2dx_experimental_auto'), \\ 'cocos2dx_controller.ini' : ('cocos2dx_controller', 'lua_cocos2dx_controller_auto'), \\ 'cocos2dx_cocosbuilder.ini': ('cocos2dx_cocosbuilder', 'lua_cocos2dx_cocosbuilder_auto'), \\ 'cocos2dx_cocosdenshion.ini': ('cocos2dx_cocosdenshion', 'lua_cocos2dx_cocosdenshion_auto'), \\ 'cocos2dx_3d.ini': ('cocos2dx_3d', 'lua_cocos2dx_3d_auto'), \\ 'cocos2dx_audioengine.ini': ('cocos2dx_audioengine', 'lua_cocos2dx_audioengine_auto'), \\ 'cocos2dx_csloader.ini' : ('cocos2dx_csloader', 'lua_cocos2dx_csloader_auto'), \\ 'cocos2dx_experimental_webview.ini' : ('cocos2dx_experimental_webview', 'lua_cocos2dx_experimental_webview_auto'), \\ 'cocos2dx_physics3d.ini' : ('cocos2dx_physics3d', 'lua_cocos2dx_physics3d_auto'), \\ 'cocos2dx_navmesh.ini' : ('cocos2dx_navmesh', 'lua_cocos2dx_navmesh_auto'), \\ } 为： cmd_args = {'MyClass.ini' : ('MyClass', \"lua_customclass_auto\")} 其意义就是根据MyClass.ini文件自动生成用于注册的lua_customclass_auto.cpp以及.hpp文件。修改完后保存退出。在命令行切换到这个目录，然后运行脚本： $python genbindings_custom.py 这里可能碰到一个坑，要注意一下，就是，运行脚本可能会出现这样的错误： ==== Errors in parsing headers: 1. &lt;severity = Fatal, location = &lt;SourceLocation file '/home/xxx/NDK/platforms/android-14/arch-arm/usr/include/android/log.h', line 70, column 10>, details = \"'stdarg.h' file not found\"> ==== 这个错误的原因是genbindings_custom.py脚本与ndk不兼容的问题，因为找不的ndk中的llvm-3.3文件夹，如果出现这个错误，先查看自己ndk目录的toolchains文件夹，看看自己是什么版本的llvm。我这里有llvm-3.5和llvm-3.6两个相关的文件夹，而在genbindings_custom.py脚本中有这么一段： if '3.4' in llvm_path: config.set('DEFAULT', 'clang_version', '3.4') else: config.set('DEFAULT', 'clang_version', '3.3') 这一段应该是用于处理早期的ndk的脚本，我的ndk应该比较新，在这里不适用，所以应该进行修改。为了偷懒，我直接将3.3改为了3.5： if '3.4' in llvm_path: config.set('DEFAULT', 'clang_version', '3.4') else: config.set('DEFAULT', 'clang_version', '3.5') 运行脚本，现在显示成功生成了： --------------------------------- Generating lua bindings succeeds. --------------------------------- 在AppDelegate.cpp中注册自定义的c++类自动生成的cpp文件在LuaTest/frameworks/cocos2d-x/cocos/scripting/lua-bindings/auto/路径下，因为我们之前在脚本中设置的名字为lua_customclass_auto，所以在这里可以找到lua_customclass_auto.cpp，lua_customclass_auto.hpp两个文件。将这两个文件拷贝到MyClass.cpp所在路径下，并且同样的在makefile中添加lua_customclass_auto.cpp文件。例如我的Linux的设置是修改CMakeList.txt： set(GAME_SRC runtime-src/proj.linux/main.cpp runtime-src/Classes/AppDelegate.cpp runtime-src/Classes/MyClass.cpp runtime-src/Classes/lua_customclass_auto.cpp ) 生成的lua_customclass_auto文件就是脚本读取MyClass后根据其内容自动生成的用于注册的文件，打开lua_customclass_auto.hpp可以看到： #include \"base/ccConfig.h\" #ifndef __MyClass_h__ #define __MyClass_h__ #ifdef __cplusplus extern \"C\" { #endif #include \"tolua++.h\" #ifdef __cplusplus } #endif int register_all_MyClass(lua_State* tolua_S); #endif // __MyClass_h__ 这里有一个register_all_MyClass方法，调用这个方法就可以向lua注册我们自定义的c++类。所以最后，打开AppDelegate.cpp，找到lua注册相关的代码，修改为： // register lua module auto engine = LuaEngine::getInstance(); ScriptEngineManager::getInstance()->setScriptEngine(engine); lua_State* L = engine->getLuaStack()->getLuaState(); lua_module_register(L); register_all_packages(); LuaStack* stack = engine->getLuaStack(); stack->setXXTEAKeyAndSign(\"2dxLua\", strlen(\"2dxLua\"), \"XXTEA\", strlen(\"XXTEA\")); //register custom function //LuaStack* stack = engine->getLuaStack(); //register_custom_function(stack->getLuaState()); // 这里注册自定义的c++类 register_all_MyClass(stack->getLuaState()); 并且记得在AppDelegate.cpp中include一下lua_customclass_auto.hpp文件，不然没法访问到register_all_MyClass函数。 最后，在lua代码中进行测试： local customClass = custom.MyClass:create() print(\"lua bind: \"..customClass:test(100)) 没错误的话就成功啦。","tags":[{"name":"cocos2d","slug":"cocos2d","permalink":"http://yoursite.com/tags/cocos2d/"}]},{"title":"Cocos2dx:绘制流程","date":"2016-04-13T13:52:41.000Z","path":"2016/04/13/cocos2d-render/","text":"cocos2d绘制流程cocos2d进行绘制主要分成了三个步骤： 每一个ui元素提交绘制命令(RenderCommand)到绘制队列(RenderQueue) 绘制队列对将要绘制的元素进行排序，确定绘制顺序 Renderer执行绘制命令进行绘制 ui树cocos2d的ui元素是通过一个树状结构来管理的，树的每个节点都是Node及其子类，例如正在显示的一个场景，Scene为树根，通过addChild方法添加的Layer、Sprite等都是其子节点。cocos2d启动进入主循环后，每次循环都会遍历一边ui树，Director的mainloop方法如下： void DisplayLinkDirector::mainLoop() { if (_purgeDirectorInNextLoop) { _purgeDirectorInNextLoop = false; purgeDirector(); } else if (_restartDirectorInNextLoop) { _restartDirectorInNextLoop = false; restartDirector(); } else if (! _invalid) { drawScene(); // release the objects PoolManager::getInstance()->getCurrentPool()->clear(); } } 跟绘制有关的即drawScene方法了，跳转过去，在Director::drawScene()中有： if (_runningScene) { #if (CC_USE_PHYSICS || (CC_USE_3D_PHYSICS &amp;&amp; CC_ENABLE_BULLET_INTEGRATION) || CC_USE_NAVMESH) _runningScene->stepPhysicsAndNavigation(_deltaTime); #endif //clear draw stats _renderer->clearDrawStats(); //render the scene _runningScene->render(_renderer); _eventDispatcher->dispatchEvent(_eventAfterVisit); } _runningScene就是当前正在显示的Scene，跳转到void Scene::render(Renderer* renderer)中，看到这么一句： //visit the scene visit(renderer, transform, 0); 这一句就是通过递归的方式来遍历ui树，visit方法在Node类中有实现，Scene并没有重写，所以看看Node的实现： void Node::visit(Renderer* renderer, const Mat4 &amp;parentTransform, uint32_t parentFlags) { // quick return if not visible. children won't be drawn. if (!_visible) { return; } uint32_t flags = processParentFlags(parentTransform, parentFlags); // IMPORTANT: // To ease the migration to v3.0, we still support the Mat4 stack, // but it is deprecated and your code should not rely on it _director->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW); _director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, _modelViewTransform); bool visibleByCamera = isVisitableByVisitingCamera(); int i = 0; if(!_children.empty()) { sortAllChildren(); // draw children zOrder &lt; 0 for( ; i &lt; _children.size(); i++ ) { auto node = _children.at(i); if (node &amp;&amp; node->_localZOrder &lt; 0) node->visit(renderer, _modelViewTransform, flags); else break; } // self draw if (visibleByCamera) this->draw(renderer, _modelViewTransform, flags); for(auto it=_children.cbegin()+i; it != _children.cend(); ++it) (*it)->visit(renderer, _modelViewTransform, flags); } else if (visibleByCamera) { this->draw(renderer, _modelViewTransform, flags); } _director->popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW); } 方法中先对此Node进行了一个可见判断，如果不可见，则不用绘制。如果此Node有子节点，则对子节点进行排序后递归调用visit方法。排序是通过子节点的zOrder来进行的，zOrder越小则排在越前面，先依次递归zOrder小于0的子节点，然后是自身，再然后是zOrder大于0的子节点。可以看出这是一个前序的遍历方法，确保了绘制顺序不出现问题。Node绘制自身调用了一个draw方法，再到draw方法里： void Node::draw(Renderer* renderer, const Mat4 &amp;transform, uint32_t flags) { } 嗯，是空的。因为Node并不是用来加载显示纹理的，前面提到显示纹理是交给了Sprite类，所以应该看Sprite类的draw方法： void Sprite::draw(Renderer *renderer, const Mat4 &amp;transform, uint32_t flags) { #if CC_USE_CULLING // Don't do calculate the culling if the transform was not updated _insideBounds = (flags &amp; FLAGS_TRANSFORM_DIRTY) ? renderer->checkVisibility(transform, _contentSize) : _insideBounds; if(_insideBounds) #endif { _trianglesCommand.init(_globalZOrder, _texture->getName(), getGLProgramState(), _blendFunc, _polyInfo.triangles, transform, flags); renderer->addCommand(&amp;_trianglesCommand); } } _insideBounds是对此Sprite的可见性判断，如果不在屏幕内则裁剪掉，不参与绘制。通过判断后，Sprite将一个RenderCommand提交到了Renderer。 RenderCommandcocos2d中RenderCommand有很多种，在RenderCommand类中定义了： enum class Type { /** Reserved type.*/ UNKNOWN_COMMAND, /** Quad command, used for draw quad.*/ QUAD_COMMAND, /**Custom command, used for calling callback for rendering.*/ CUSTOM_COMMAND, /**Batch command, used for draw batches in texture atlas.*/ BATCH_COMMAND, /**Group command, which can group command in a tree hierarchy.*/ GROUP_COMMAND, /**Mesh command, used to draw 3D meshes.*/ MESH_COMMAND, /**Primitive command, used to draw primitives such as lines, points and triangles.*/ PRIMITIVE_COMMAND, /**Triangles command, used to draw triangles.*/ TRIANGLES_COMMAND }; 不同的RenderCommand会用在不同的地方，例如在Sprite里面用到的是TrianglesCommand： class CC_DLL TrianglesCommand : public RenderCommand { public: /**The structure of Triangles. */ struct Triangles { /**Vertex data pointer.*/ V3F_C4B_T2F* verts; /**Index data pointer.*/ unsigned short* indices; /**The number of vertices.*/ ssize_t vertCount; /**The number of indices.*/ ssize_t indexCount; }; // ... protected: /**Generate the material ID by textureID, glProgramState, and blend function.*/ void generateMaterialID(); /**Generated material id.*/ uint32_t _materialID; /**OpenGL handle for texture.*/ GLuint _textureID; /**GLprogramstate for the commmand. encapsulate shaders and uniforms.*/ GLProgramState* _glProgramState; /**Blend function when rendering the triangles.*/ BlendFunc _blendType; /**Rendered triangles.*/ Triangles _triangles; /**Model view matrix when rendering the triangles.*/ Mat4 _mv; }; （删去了一部分代码）其中定义了一个struct类用于描述三角形，其中V3F_C4B_T2F用于描述顶点信息（Vertices：顶点，3个float；Color：颜色，4位；Texture：纹理，2个float)，剩下三个分别是索引信息，顶点数和索引数。所以可以看出RenderCommand实际上是对一些opengl参数的封装，遍历完ui树后，cocos2d再将opengl参数传递给opengl进行绘制。 RendererRenderCommand提交完毕后，Renderer会根据绘制命令进行绘制。在Scene的render方法最后，调用了Renderer的render方法： renderer->render(); Renderer的render方法如下： void Renderer::render() { //Uncomment this once everything is rendered by new renderer //glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //TODO: setup camera or MVP _isRendering = true; if (_glViewAssigned) { //Process render commands //1. Sort render commands based on ID for (auto &amp;renderqueue : _renderGroups) { renderqueue.sort(); } visitRenderQueue(_renderGroups[0]); } clean(); _isRendering = false; } Renderer通过维护的RenderQueue数组来访问RenderCommand，默认的主队列是标记为0的RenderQueue，之后的RenderQueue跟GroupCommand有关，每一个GroupCommand会指向一个RenderQueue，这样就可以采用不同的绘制选项。这里依次访问所有队列进行了排序，看看RenderQueue的sort方法： void RenderQueue::sort() { // Don't sort _queue0, it already comes sorted std::sort(std::begin(_commands[QUEUE_GROUP::TRANSPARENT_3D]), std::end(_commands[QUEUE_GROUP::TRANSPARENT_3D]), compare3DCommand); std::sort(std::begin(_commands[QUEUE_GROUP::GLOBALZ_NEG]), std::end(_commands[QUEUE_GROUP::GLOBALZ_NEG]), compareRenderCommand); std::sort(std::begin(_commands[QUEUE_GROUP::GLOBALZ_POS]), std::end(_commands[QUEUE_GROUP::GLOBALZ_POS]), compareRenderCommand); } 第一句是对3d的绘制命令进行了排序，这里暂且不去了解；后两句是对GlobalZOrder小于0和大于0的命令进行了排序，GlobalZOrder为0的不进行排序。原因是所有ui元素默认的GlobalZOrder都是0, 在ui树的遍历过程中，实际上已经完成了这些ui元素的排序（前序遍历），故这里不需要再排序。GlobalZOrder的用途实际上是动态改变一个ui元素的绘制次序用的，所以一般情况下不需要对GlobalZOrder进行特殊的设置，这样可以减少性能消耗。 接着render方法调用了visitRenderCommand方法： void Renderer::visitRenderQueue(RenderQueue&amp; queue) { queue.saveRenderState(); // //Process Global-Z = 0 Queue // const auto&amp; zZeroQueue = queue.getSubQueue(RenderQueue::QUEUE_GROUP::GLOBALZ_ZERO); if (zZeroQueue.size() > 0) { if(_isDepthTestFor2D) { glEnable(GL_DEPTH_TEST); glDepthMask(true); RenderState::StateBlock::_defaultState->setDepthTest(true); RenderState::StateBlock::_defaultState->setDepthWrite(true); } else { glDisable(GL_DEPTH_TEST); glDepthMask(false); RenderState::StateBlock::_defaultState->setDepthTest(false); RenderState::StateBlock::_defaultState->setDepthWrite(false); } for (auto it = zZeroQueue.cbegin(); it != zZeroQueue.cend(); ++it) { processRenderCommand(*it); } flush(); } queue.restoreRenderState(); } 代码比较长，这里只保留GlobalZOrder为0的，方法开始时是一些opengl参数的处理，比如深度测试的开启与否，然后出现一句processRenderCommand，从名字上看应该是执行绘制命令，开始绘制了： void Renderer::processRenderCommand(RenderCommand* command) { auto commandType = command->getType(); if( RenderCommand::Type::TRIANGLES_COMMAND == commandType) { //Draw if we have batched other commands which are not triangle command flush3D(); flushQuads(); //Process triangle command auto cmd = static_cast&lt;TrianglesCommand*>(command); //Draw batched Triangles if necessary if(cmd->isSkipBatching() || _filledVertex + cmd->getVertexCount() > VBO_SIZE || _filledIndex + cmd->getIndexCount() > INDEX_VBO_SIZE) { CCASSERT(cmd->getVertexCount()>= 0 &amp;&amp; cmd->getVertexCount() &lt; VBO_SIZE, \"VBO for vertex is not big enough, please break the data down or use customized render command\"); CCASSERT(cmd->getIndexCount()>= 0 &amp;&amp; cmd->getIndexCount() &lt; INDEX_VBO_SIZE, \"VBO for index is not big enough, please break the data down or use customized render command\"); //Draw batched Triangles if VBO is full drawBatchedTriangles(); } //Batch Triangles _batchedCommands.push_back(cmd); fillVerticesAndIndices(cmd); if(cmd->isSkipBatching()) { drawBatchedTriangles(); } } // ... else { CCLOGERROR(\"Unknown commands in renderQueue\"); } } 这个方法主要是根据不同的绘制命令进行不同的处理，代码较多，只保留了TrianglesCommand的处理。对TrianglesCommand的处理是，首先先绘制之前缓存的其它种类命令，例如QuadCommand等，然后如果缓存队列不满或者没有设置成不参与批绘制，则将当前命令添加到缓存队列，留带稍后一起处理。 drawBatchedTriangles就是对已经缓存的TrianglesCommand进行绘制的方法： void Renderer::drawBatchedTriangles() { //TODO: we can improve the draw performance by insert material switching command before hand. int indexToDraw = 0; int startIndex = 0; //Upload buffer to VBO if(_filledVertex &lt;= 0 || _filledIndex &lt;= 0 || _batchedCommands.empty()) { return; } if (Configuration::getInstance()->supportsShareableVAO()) { //Bind VAO GL::bindVAO(_buffersVAO); //Set VBO data glBindBuffer(GL_ARRAY_BUFFER, _buffersVBO[0]); // option 1: subdata // glBufferSubData(GL_ARRAY_BUFFER, sizeof(_quads[0])*start, sizeof(_quads[0]) * n , &amp;_quads[start] ); // option 2: data // glBufferData(GL_ARRAY_BUFFER, sizeof(quads_[0]) * (n-start), &amp;quads_[start], GL_DYNAMIC_DRAW); // option 3: orphaning + glMapBuffer glBufferData(GL_ARRAY_BUFFER, sizeof(_verts[0]) * _filledVertex, nullptr, GL_DYNAMIC_DRAW); void *buf = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY); memcpy(buf, _verts, sizeof(_verts[0])* _filledVertex); glUnmapBuffer(GL_ARRAY_BUFFER); glBindBuffer(GL_ARRAY_BUFFER, 0); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _buffersVBO[1]); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(_indices[0]) * _filledIndex, _indices, GL_STATIC_DRAW); } else { #define kQuadSize sizeof(_verts[0]) glBindBuffer(GL_ARRAY_BUFFER, _buffersVBO[0]); glBufferData(GL_ARRAY_BUFFER, sizeof(_verts[0]) * _filledVertex , _verts, GL_DYNAMIC_DRAW); GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POS_COLOR_TEX); // vertices glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 3, GL_FLOAT, GL_FALSE, kQuadSize, (GLvoid*) offsetof(V3F_C4B_T2F, vertices)); // colors glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, kQuadSize, (GLvoid*) offsetof(V3F_C4B_T2F, colors)); // tex coords glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, kQuadSize, (GLvoid*) offsetof(V3F_C4B_T2F, texCoords)); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _buffersVBO[1]); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(_indices[0]) * _filledIndex, _indices, GL_STATIC_DRAW); } //Start drawing verties in batch for(const auto&amp; cmd : _batchedCommands) { auto newMaterialID = cmd->getMaterialID(); if(_lastMaterialID != newMaterialID || newMaterialID == MATERIAL_ID_DO_NOT_BATCH) { //Draw quads if(indexToDraw > 0) { glDrawElements(GL_TRIANGLES, (GLsizei) indexToDraw, GL_UNSIGNED_SHORT, (GLvoid*) (startIndex*sizeof(_indices[0])) ); _drawnBatches++; _drawnVertices += indexToDraw; startIndex += indexToDraw; indexToDraw = 0; } //Use new material cmd->useMaterial(); _lastMaterialID = newMaterialID; } indexToDraw += cmd->getIndexCount(); } //Draw any remaining triangles if(indexToDraw > 0) { glDrawElements(GL_TRIANGLES, (GLsizei) indexToDraw, GL_UNSIGNED_SHORT, (GLvoid*) (startIndex*sizeof(_indices[0])) ); _drawnBatches++; _drawnVertices += indexToDraw; } if (Configuration::getInstance()->supportsShareableVAO()) { //Unbind VAO GL::bindVAO(0); } else { glBindBuffer(GL_ARRAY_BUFFER, 0); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); } _batchedCommands.clear(); _filledVertex = 0; _filledIndex = 0; } 这里做了三步处理： 将顶点、颜色、纹理等数据缓存到GPU 批绘制三角形 绘制没有被批绘制的剩余三角形 比较值得提及是第2点，cocos2d在这里做了一个自动批绘制的功能，即如下这段代码： //Start drawing verties in batch for(const auto&amp; cmd : _batchedCommands) { auto newMaterialID = cmd->getMaterialID(); if(_lastMaterialID != newMaterialID || newMaterialID == MATERIAL_ID_DO_NOT_BATCH) { //Draw quads if(indexToDraw > 0) { glDrawElements(GL_TRIANGLES, (GLsizei) indexToDraw, GL_UNSIGNED_SHORT, (GLvoid*) (startIndex*sizeof(_indices[0])) ); _drawnBatches++; _drawnVertices += indexToDraw; startIndex += indexToDraw; indexToDraw = 0; } //Use new material cmd->useMaterial(); _lastMaterialID = newMaterialID; } indexToDraw += cmd->getIndexCount(); } 如果上一条绘制命令所使用的materialID与当前的相同，先不做处理，直到materialID不同的绘制命令出现，则将之前的命令统一绘制。其原理是将使用同一纹理、同一着色器、同一混合方程等gl参数的命令集中到一起来绘制，这样可以减少glDraw的调用次数，提升性能。 至于materialID是什么，在TrianglesCommand里面可以看到，其生成的方法为： void TrianglesCommand::generateMaterialID() { if(_glProgramState->getUniformCount() > 0) { _materialID = Renderer::MATERIAL_ID_DO_NOT_BATCH; } else { int glProgram = (int)_glProgramState->getGLProgram()->getProgram(); int intArray[4] = { glProgram, (int)_textureID, (int)_blendType.src, (int)_blendType.dst}; _materialID = XXH32((const void*)intArray, sizeof(intArray), 0); } } 当此ui元素使用了非默认着色器时，其materialID会被设置为Renderer::MATERIAL_ID_DO_NOT_BATCH，将无法参与自动批绘制。如果采用默认处理，则会通过其使用的着色器、纹理以及混合方程来计算一个hash值，materialID就是这个hash值。就是说，判断两个ui元素能否参与自动批绘制，只需要判断materialID是否相同，如果相同，则说明二者的gl参数一致，可以在同一次glDraw里面完成绘制。不过自动批绘制只能将相邻的RenderCommand进行合并，所以写程序的时候应该考虑到这一点来进行优化。 总结cocos2d绘制的大致流程就是以上，即：每次游戏循环，对ui树进行遍历时，cocos2d不会立即进行绘制，而是让每一个ui元素提交一个绘制命令（RenderCommand）。遍历完一次ui树后，会生成一个绘制命令队列（RenderQueue），绘制器（Renderer）会先对绘制队列进行排序，然后开始绘制。绘制过程中采用了自动批绘制的技术对绘制进行优化，即合并使用同一着色器、纹理以及混合方程的绘制命令，以达到性能优化的目的。","tags":[{"name":"cocos2d","slug":"cocos2d","permalink":"http://yoursite.com/tags/cocos2d/"}]},{"title":"Cocos2dx:TileMap的使用（二）","date":"2016-03-27T07:02:33.000Z","path":"2016/03/27/cocos2d-tilemap02/","text":"上一篇主要介绍了在cocos2d中tilemap的加载使用方法，这一篇就简要查看一下cocos2d这部分的源码，看看cocos2d是如何解析tilemap中的数据的。 创建tilemap的代码如下： TMXTiledMap* tilemap = TMXTiledMap::create(\"Map/tilemap.tmx\"); this->addChild(tilemap); 可以看到cocos2d中调用了TMXTiledMap类的create方法，其内容为： TMXTiledMap * TMXTiledMap::create(const std::string&amp; tmxFile) { TMXTiledMap *ret = new (std::nothrow) TMXTiledMap(); if (ret->initWithTMXFile(tmxFile)) { ret->autorelease(); return ret; } CC_SAFE_DELETE(ret); return nullptr; } create方法没做什么特别的事情，主要还是跳转到了initWithTMXFile方法： bool TMXTiledMap::initWithTMXFile(const std::string&amp; tmxFile) { CCASSERT(tmxFile.size()>0, \"TMXTiledMap: tmx file should not be empty\"); setContentSize(Size::ZERO); TMXMapInfo *mapInfo = TMXMapInfo::create(tmxFile); if (! mapInfo) { return false; } CCASSERT( !mapInfo->getTilesets().empty(), \"TMXTiledMap: Map not found. Please check the filename.\"); buildWithMapInfo(mapInfo); return true; } 从init方法里面得知，tmx文件的解析工作不是交给TMXTiledMap类做的，而是将tmx的路径传给了TMXMapInfo类，TMXMapInfo处理好地图的各项数据，自己再使用TMXMapInfo的结果创建地图。这里先查看TMXMapInfo的内容，TMXMapInfo类定义在cocos/2d/CCTMXXMLParser.h文件中，注意一下这里TMXMapInfo类不仅继承了Ref，还继承了SAXDelegator类，具体内容等一下再看。 class CC_DLL TMXMapInfo : public Ref, public SAXDelegator TMXMapInfo的create方法东西也不多，只是做了创建工作，初始化交给了initWithTMXFile： TMXMapInfo * TMXMapInfo::create(const std::string&amp; tmxFile) { TMXMapInfo *ret = new (std::nothrow) TMXMapInfo(); if (ret->initWithTMXFile(tmxFile)) { ret->autorelease(); return ret; } CC_SAFE_DELETE(ret); return nullptr; } 转到initWithTMXFile： bool TMXMapInfo::initWithTMXFile(const std::string&amp; tmxFile) { internalInit(tmxFile, \"\"); return parseXMLFile(_TMXFileName.c_str()); } internalInit就是一些成员变量的的初始化工作，parseXMLFile的内容如下： bool TMXMapInfo::parseXMLFile(const std::string&amp; xmlFilename) { SAXParser parser; if (false == parser.init(\"UTF-8\") ) { return false; } parser.setDelegator(this); return parser.parse(FileUtils::getInstance()->fullPathForFilename(xmlFilename).c_str()); } 从这里看到，tmx文件的解析最后是交给了SAXParser，且SAXParser的delegator设置为了TMXMapInfo。上面说TMXMapInfo继承了SAXDelegator，所以就将TMXMapInfo和SAXParser关联起来了。此方法最后调用了SAXParser的parse方法进行解析，解析的结果也将交由TMXMapInfo来处理。SAXParser及Delegator的定义在cocos/platform/CCSAXParser.h中。SAXParser的parse方法如下： bool SAXParser::parse(const char* xmlData, size_t dataLength) { tinyxml2::XMLDocument tinyDoc; tinyDoc.Parse(xmlData, dataLength); XmlSaxHander printer; printer.setSAXParserImp(this); return tinyDoc.Accept( &amp;printer ); } cocos2d对tmx文件的解析是交给了第三方的xml解析工具tinyxml2来解析的，前上一篇中讲了，tmx文件实际上就是一个xml文件，所以用xml解析器进行解析就可以了。在这里XmlSaxHander类继承了tinyxml2::XMLVisitor类，并且重写了其中的Visit等方法，就是说，在tinyxml2解析tmx的过程中，会调用XmlSaxHander的相应方法，比如XmlSaxHander::VisitEnter： bool XmlSaxHander::VisitEnter( const tinyxml2::XMLElement&amp; element, const tinyxml2::XMLAttribute* firstAttribute ) { // log(\" VisitEnter %s\",element.Value()); std::vector&lt;const char*> attsVector; for( const tinyxml2::XMLAttribute* attrib = firstAttribute; attrib; attrib = attrib->Next() ) { // log(\"%s\", attrib->Name()); attsVector.push_back(attrib->Name()); // log(\"%s\",attrib->Value()); attsVector.push_back(attrib->Value()); } // nullptr is used in c++11 //attsVector.push_back(nullptr); attsVector.push_back(nullptr); SAXParser::startElement(_ccsaxParserImp, (const CC_XML_CHAR *)element.Value(), (const CC_XML_CHAR **)(&amp;attsVector[0])); return true; } attsVector储存了tinyxml2解析出的属性名称以及其值，并且在return之前，又调用了SAXParser的startElement方法，传入了attsVector。SAXParser的startElement方法是调用的其Delegator的startElement方法，而我们知道TMXMapInfo继承了SAXDelegator并进行了设置，故实际上调用的是TMXMapInfo的startElement方法。所以最后还是回到了TMXMapInfo类里面： // the XML parser calls here with all the elements void TMXMapInfo::startElement(void *ctx, const char *name, const char **atts) { // ... if (elementName == \"map\"){/*...*/} else if (elementName == \"tileset\") {/*...*/} else if (elementName == \"tile\"){/*...*/} else if (elementName == \"layer\"){/*...*/} else if (elementName == \"objectgroup\"){/*...*/} else if (elementName == \"image\"){/*...*/} else if (elementName == \"data\"){/*...*/} else if (elementName == \"object\"){/*...*/} else if (elementName == \"property\"){/*...*/} else if (elementName == \"polygon\") {/*...*/} else if (elementName == \"polyline\"){/*...*/} } 由于代码太长，只提取了主要部分。看到一堆if里面的内容是不是很熟悉？回忆上一篇讲到的tmx文件的格式，可以知道是在这里，cocos2d对解析出来的数据进行了处理，挑其中一个，例如object的内容： /*...*/ else if (elementName == \"object\") { TMXObjectGroup* objectGroup = tmxMapInfo->getObjectGroups().back(); // The value for \"type\" was blank or not a valid class name // Create an instance of TMXObjectInfo to store the object and its properties ValueMap dict; // Parse everything automatically const char* keys[] = {\"name\", \"type\", \"width\", \"height\", \"gid\"}; for (const auto&amp; key : keys) { Value value = attributeDict[key]; dict[key] = value; } // But X and Y since they need special treatment // X int x = attributeDict[\"x\"].asInt(); // Y int y = attributeDict[\"y\"].asInt(); Vec2 p(x + objectGroup->getPositionOffset().x, _mapSize.height * _tileSize.height - y - objectGroup->getPositionOffset().y - attributeDict[\"height\"].asInt()); p = CC_POINT_PIXELS_TO_POINTS(p); dict[\"x\"] = Value(p.x); dict[\"y\"] = Value(p.y); int width = attributeDict[\"width\"].asInt(); int height = attributeDict[\"height\"].asInt(); Size s(width, height); s = CC_SIZE_PIXELS_TO_POINTS(s); dict[\"width\"] = Value(s.width); dict[\"height\"] = Value(s.height); // Add the object to the objectGroup objectGroup->getObjects().push_back(Value(dict)); // The parent element is now \"object\" tmxMapInfo->setParentElement(TMXPropertyObject); } 代码很好懂，就是当解析到object时，对应object所含有的属性，从attributeDict找到其值，例如name、type等等，然后丢到dict里面存储起来就可以了。 回到TMXTiledMap类中来，当TMXMapInfo解析完数据后，TMXTileMap就根据数据绘制地图，其buildWithMapInfo方法如下： void TMXTiledMap::buildWithMapInfo(TMXMapInfo* mapInfo) { _mapSize = mapInfo->getMapSize(); _tileSize = mapInfo->getTileSize(); _mapOrientation = mapInfo->getOrientation(); _objectGroups = mapInfo->getObjectGroups(); _properties = mapInfo->getProperties(); _tileProperties = mapInfo->getTileProperties(); int idx=0; auto&amp; layers = mapInfo->getLayers(); for(const auto &amp;layerInfo : layers) { if (layerInfo->_visible) { TMXLayer *child = parseLayer(layerInfo, mapInfo); if (child == nullptr) { idx++; continue; } addChild(child, idx, idx); // update content size with the max size const Size&amp; childSize = child->getContentSize(); Size currentSize = this->getContentSize(); currentSize.width = std::max( currentSize.width, childSize.width ); currentSize.height = std::max( currentSize.height, childSize.height ); this->setContentSize(currentSize); idx++; } } } 除了地图基本信息，绘制地图主要的是各个Layer的内容，所以在这里可以看到Layer被依次获取，通过TMXLayer进行了加载，这里就不再详细叙述了。 总结总结一下，cocos2d中加载tilemap的过程，简单来说，就是： 创建TMXTiledMap类时，其创建了一个TMXMapInfo类的实例。 TMXMapInfo类初始化时，使用了tinyxml2对tmx文件进行了解析，并且对解析的数据进行了处理。 TMXMapInfo初始化完毕后，对数据处理也完毕了，这时候TMXTiledMap类直接通过TMXMapInfo的数据创建地图即可。","tags":[{"name":"cocos2d","slug":"cocos2d","permalink":"http://yoursite.com/tags/cocos2d/"},{"name":"tilemap","slug":"tilemap","permalink":"http://yoursite.com/tags/tilemap/"}]},{"title":"Cocos2dx:TileMap的使用（一）","date":"2016-03-26T12:47:32.000Z","path":"2016/03/26/cocos2d-tilemap01/","text":"针对如何在cocos2d中使用tilemap来加载地图的步骤网上基本都有教程，比如怎么使用Tiled创建tilemap，以及如何在cocos2d中加载，网上都能搜索到，这里只简单说一下，不列出具体步骤。这篇文章主要是对tilemap文件的格式以及cocos2d如何加载tilemap做了一个简单的分析，以备日后查看。 在cocos2d中创建并加载tilemap使用Tiled创建好tilemap后，接下来需要用代码在cocos2d中加载它，代码如下： TMXTiledMap* tilemap = TMXTiledMap::create(\"Map/tilemap.tmx\"); this->addChild(tilemap); 这样便很简单地创建了tilemap。不过这里有几点要注意一下，一是使用Tiled创建tilemap的时候，添加了tileset之类资源的话，一定要把资源放到与tmx文件同一个目录下，避免无法加载的情况出现；二是新建tilemap时，格式应选择Base64(zlib compressed)，不然cocos2d可能会出现加载失败的情况。 tmx文件的结构cocos2d可以通过tmx文件加载tilemap，而tmx文件其实就是xml格式的文件，其具体格式在这里可以看到。例如如下tmx文件内容： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;map version=\"1.0\" orientation=\"orthogonal\" renderorder=\"right-down\" width=\"60\" height=\"40\" tilewidth=\"32\" tileheight=\"32\" nextobjectid=\"13\"> &lt;tileset firstgid=\"1\" name=\"tiles-hd\" tilewidth=\"32\" tileheight=\"32\" tilecount=\"256\" columns=\"16\"> &lt;image source=\"tiles-hd.png\" width=\"512\" height=\"512\"/> &lt;/tileset> &lt;layer name=\"Tile Layer 1\" width=\"60\" height=\"40\"> &lt;data encoding=\"base64\" compression=\"zlib\"> eJzt0YEJAEAMg8DS/YfuFv+g3gSR7IRsfw94zNZrY/u33pDY/q2XzdZrY/u3XrZ6Q2L7t142W6+N7d96Q2L719Zr079stn/rZauXzdZ7shwAPw== &lt;/data> &lt;/layer> &lt;objectgroup name=\"Objects\"> &lt;object id=\"1\" type=\"1\" x=\"53.6875\" y=\"1200.9\"> &lt;polyline points=\"0,0 1426.96,-8.47697 1850.81,8.47697\"/> &lt;/object> &lt;object id=\"6\" type=\"2\" x=\"771.404\" y=\"180.842\"> &lt;polygon points=\"0,0 127.155,418.197 508.618,573.608 599.039,319.299 401.243,73.4671\"/> &lt;/object> &lt;object id=\"7\" type=\"4\" x=\"262.786\" y=\"576.434\" width=\"192.145\" height=\"200.622\"/> &lt;object id=\"9\" type=\"3\" x=\"1491.95\" y=\"243.006\" width=\"121.503\" height=\"161.062\"> &lt;ellipse/> &lt;/object> &lt;/objectgroup> &lt;/map> map 标签：储存了此tilemap的主要信息，例如朝向，宽高等等。 tileset 标签：是此tilemap中导入的tileset资源的信息，例如图片源 layer 标签：层相关的信息，如果地图中有多个层，则也会有多个layer标签 data 标签：出现在layer里，其实定义的就是地图信息，如果加密方式选择csv，就可以看到其中的内容例如： &lt;data encoding=\"csv\"> 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0 &lt;/data> 这是一个10行10列的地图，0代表没有图块，如果有数字，例如1,就代表tileset中第一个图块，2就代表第二个，以此类推。 objectgroup 这个是object层的信息，其中会包括多个 object 标签，记录了每个object的信息，obejct有多种类型： 四边形：四边形没有特殊标签，直接用object标签即可表示： &lt;object id=\"7\" type=\"4\" x=\"262.786\" y=\"576.434\" width=\"192.145\" height=\"200.622\"/> 其中x、y为四边形左下角点的坐标，width、height即为宽、长。 椭圆 使用 ellipse 标签。 &lt;object id=\"9\" type=\"3\" x=\"1491.95\" y=\"243.006\" width=\"121.503\" height=\"161.062\"> &lt;ellipse/> &lt;/object> 多边形 使用 polygon 标签，object中的x、y为多边形的起始点，polygon中的points记录了多边形各个顶点的坐标，其中第一个始终为(0,0)，其余点都是相对第一个点的位移。 &lt;object id=\"6\" type=\"2\" x=\"771.404\" y=\"180.842\"> &lt;polygon points=\"0,0 127.155,418.197 508.618,573.608 599.039,319.299 401.243,73.4671\"/> &lt;/object> 折线 使用 polyline 标签，表示方式类似于polygon，其实折线可以看做不封口的多边形。 &lt;object id=\"1\" type=\"1\" x=\"53.6875\" y=\"1200.9\"> &lt;polyline points=\"0,0 1426.96,-8.47697 1850.81,8.47697\"/> &lt;/object> 在cocos2d中解析tilemap的数据虽然在cocos2d中加载tilemap非常简单，但是实际使用中经常不仅仅要加载tilemap，实际上还需要通过tilemap传入地图的一些信息，例如使用物理引擎时，需要获知地图中有哪些碰撞物；怪物会在哪里生成；在哪些地方会触发事件等等。信息足够的话，其实可以将Tiled当作关卡编辑器使用，减轻编码负担。 tilemap中常用的层有地图层和object层，下面简单介绍一下两者信息的获取方法： 地图层 使用TMXTiledMap类的getLayer方法可以获取到地图层，如果获取成功，会返回一个TMXLayer对象，通过TMXLayer对象可以获取地图层的信息，具体提供的方法可以访问官网查看api：TMXLayer。 TMXLayer* layer = tilemap->getLayer(\"Layer\"); log(\"%s\", layer->getDescription().c_str()); Sprite* sp = layer->getTileAt(Vec2(0, 15)); sp->setPosition(visibleSize/2); 注意一下，以上代码中getTileAt获取到的是已经作为layer的字节点的sprite对象，改变其位置后，原来地图上对应的图块就改变了位置。 object层通过TMXTiledMap的getObjectGroup方法可以获取到object层对象，该方法返回的是一个TMXObjectGroup对象，其api查看TMXObjectGroup，示例代码如下： tilemap = TMXTiledMap::create(\"Map/tilemap.tmx\"); this->addChild(tilemap); TMXObjectGroup *objectGroup = tilemap->getObjectGroup(\"Objects\"); for (auto&amp; object : objectGroup->getObjects()) { ValueMap obj = object.asValueMap(); switch (obj[\"type\"].asInt()) { case 1: { // polyline log(\"Polyline--------\"); log(\"x:%.2f, y:%.2f\", obj[\"x\"].asFloat(), obj[\"y\"].asFloat()); ValueVector pointsVector = obj[\"polylinePoints\"].asValueVector(); for (auto&amp; pointMap : pointsVector) { auto point = pointMap.asValueMap(); log(\"polyline point: %.2f, %.2f\", point[\"x\"].asFloat(), point[\"y\"].asFloat()); } break; } case 2: { // polygon log(\"Polygon---------\"); log(\"x:%.2f, y:%.2f\", obj[\"x\"].asFloat(), obj[\"y\"].asFloat()); ValueVector pointsVector = obj[\"points\"].asValueVector(); for (auto&amp; pointMap : pointsVector) { auto point = pointMap.asValueMap(); log(\"polygon point: %.2f, %.2f\", point[\"x\"].asFloat(), point[\"y\"].asFloat()); } break; } case 3: { // ellipse log(\"Ellipse---------\"); log(\"x:%.2f, y:%.2f\", obj[\"x\"].asFloat(), obj[\"y\"].asFloat()); log(\"width:%.2f, height:%.2f\", obj[\"width\"].asFloat(), obj[\"height\"].asFloat()); break; } case 4: { // rectangle log(\"Rectangle-------\"); log(\"x:%.2f, y:%.2f\", obj[\"x\"].asFloat(), obj[\"y\"].asFloat()); log(\"width:%.2f, height:%.2f\", obj[\"width\"].asFloat(), obj[\"height\"].asFloat()); break; } default: { CCASSERT(false, \"object must has a type!!!\"); break; } } log(\"\"); } 为了做示范，在创建tilemap时，添加了四种object，都放置在名为Objects的层中，且四种object都添加了type属性以示区别，其中折线为1,多边形为2,椭圆为3,四边形为4。 这里可能要注意一下Value的用法，这是cocos2d中存储数据的类，与其相关的还有ValueVector、ValueMap等等，具体使用方法以后再介绍。 以上代码中，TMXObjectGroup即tilemap的object层，通过其getObjects方法可以获取其中存储的所有object；之后遍历所有object，判断其type，做相关处理即可。","tags":[{"name":"cocos2d","slug":"cocos2d","permalink":"http://yoursite.com/tags/cocos2d/"},{"name":"tilemap","slug":"tilemap","permalink":"http://yoursite.com/tags/tilemap/"}]},{"title":"Cocos2dx:物理引擎碰撞检测","date":"2016-03-04T10:11:08.000Z","path":"2016/03/04/cocos2d-physics/","text":"在cocos2dx中使用物理引擎的时候，对物理世界(PhysicsWorld)中的物体设置好碰撞检测的规则是很常见的需求，对Node调用其getPhysicsBody可以获得它的PhysicsBody，通过setGroup，setCategoryBitmask，setCollisionBitmask，setContactTestBitmask等API可以设置碰撞检测的规则，下面进行一些总结： void setGroup(int group) 其优先级比bit masks的优先级高。 如果两PhysicsBody的group是正数且相等的话，就一定碰撞；如果group是负数且相等的话，就一定不会碰撞。 void setCategoryBitmask(int bitmask) 这个是用来设置该PhysicsBody的类别的方法，类别用bitmask表示，bitmask为一个32位的整型变量，每一位代表一种类别。而每一个PhysicsBody可以属于多个类别。其默认值为0xFFFFFFFF，同时属于32个类别。 例如bitmask为0x03,即0011（此处只保留了最后四位），则表示该PhysicsBody属于最后两位代表的类别，同时属于0001和0010类。 void setCollisionBitmask(int bitmask) 设置此PhysicsBody能与哪些类别的PhysicsBody产生碰撞，例如设置为0x03（即0011），则能与0001和0010两类的物体产生碰撞。 默认值0xFFFFFFFF，即能与所有类别的PhysicsBody产生碰撞。 void setContactTestBitmask(int bitmask) 使用类似于CollisionBitmask的使用，用来触发cocos2d中EventListenerPhysicsContact的回调函数，不设置的话就不会响应EventListenerPhysicsContact的事件。 默认值0x00000000，即都不响应事件。但是只是不响应事件，如果setCollisionBitMask中使得此PhysicsBody能响应碰撞，则在物理引擎的表现中此PhysicsBody依然能够响应碰撞。","tags":[{"name":"cocos2d","slug":"cocos2d","permalink":"http://yoursite.com/tags/cocos2d/"},{"name":"chipmunk","slug":"chipmunk","permalink":"http://yoursite.com/tags/chipmunk/"}]}]